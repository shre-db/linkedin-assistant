__module_name__ = "state_schema"

from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List, Literal

# Define the possible actions the Router Node can decide on
RouterAction = Literal[
    "INITIAL_WELCOME",         # For first interaction or when bot needs to re-introduce itself/options
    "AWAIT_URL",               # Bot is explicitly waiting for a LinkedIn URL
    "CALL_ANALYZE",            # Router wants to call the Profile Analyzer
    "CALL_REWRITE",            # Router wants to call the Content Rewriter
    "CALL_JOB_FIT",            # Router wants to call the Job Fit Evaluator
    "CALL_GUIDE",              # Router wants to call the Career Guide
    "RESPOND_DIRECTLY",        # Router handles the response itself (e.g., general chat, error, clarification)
    "AWAIT_CONFIRMATION",      # Router is waiting for a 'yes/no' from the user
    "REQUEST_JOB_DESCRIPTION", # Router is waiting for a job description
    "INVALID_INPUT"            # Router determined input was unparsable/unactionable
]

# Define agent types for better type safety
AgentType = Literal["analyze", "rewrite", "job_fit", "guide"]

class ProfileBotState(BaseModel):
    """
    Represents the state of our LangGraph workflow for LinkedIn optimization and career guidance.
    This state is passed between all nodes and updated accordingly.
    """
    # 1. User Input & Conversational Context
    session_id: Optional[str] = Field(None, description="Unique identifier for the user's session.")
    user_input: Optional[str] = Field(None, description="The most recent raw input string from the user.")
    conversation_history: List[Dict[str, str]] = Field(
        default_factory=list,
        description="Chronological list of messages between user and bot. Each dict: {'role': 'user'|'assistant', 'content': '...'}",
    )
    current_bot_response: Optional[str] = Field(None, description="The message generated by the bot to be sent to the user in the current turn.")

    # 2. Raw Inputs from User
    linkedin_url: Optional[str] = Field(None, description="The LinkedIn profile URL provided by the user.")
    target_job_description: Optional[str] = Field(None, description="The job description provided by the user for job fit evaluation.")
    target_role: Optional[str] = Field(None, description="The specific role/industry the user is interested in for guidance/job fit.")
    linkedin_data: Optional[Dict[str, Any]] = Field(None, description="Parsed LinkedIn profile data from scraping.")

    # 3. Agent Outputs / Processed Data
    profile_analysis_report: Optional[Dict[str, Any]] = Field(None, description="Detailed analysis report from the Profile Analyzer. Should be structured (dict).")
    content_rewrites_suggestions: Optional[Dict[str, Any]] = Field(None, description="List of suggested content rewrites from Content Rewriter.")
    job_fit_evaluation_report: Optional[Dict[str, Any]] = Field(None, description="Report from Job Fit Evaluator, including score, gaps, etc. Should be structured (dict).")
    career_guidance_notes: Optional[Dict[str, Any]] = Field(None, description="Structured guidance points/recommendations from Career Guide.")

    # 4. Control Flags & Workflow State
    current_router_action: Optional[RouterAction] = Field(None, description="The current action the router has decided upon (e.g., CALL_ANALYZE, RESPOND_DIRECTLY).")
    last_agent_called: Optional[AgentType] = Field(None, description="Stores which specialized agent was last invoked. Useful for conversational context.")
    is_profile_analyzed: bool = Field(False, description="Flag: True if profile analysis has been successfully completed.")
    awaiting_user_confirmation: bool = Field(False, description="Flag: True if the bot is waiting for a 'yes/no' or specific confirmation from the user.")
    proposed_next_action: Optional[str] = Field(None, description="The action suggested by the bot (e.g., 'rewrite' after analysis) that needs user confirmation.")
    current_task_status: Optional[str] = Field(None, description="Brief status message about ongoing task (e.g., 'Analyzing profile...', 'Generating rewrites...').")
    awaiting_job_description: bool = Field(False, description="Flag: True if bot explicitly asked for a job description and is awaiting it.")
    
    # 4a. Completion Tracking & Re-execution Control
    analysis_completed: bool = Field(False, description="Flag: True if profile analysis has been completed at least once.")
    rewrite_completed: bool = Field(False, description="Flag: True if content rewriting has been completed at least once.")
    job_fit_completed: bool = Field(False, description="Flag: True if job fit evaluation has been completed at least once.")
    guidance_completed: bool = Field(False, description="Flag: True if career guidance has been provided at least once.")
    allow_re_execution: bool = Field(True, description="Flag: True if user wants to allow re-running of completed tasks. Set to False to prevent loops.")
    user_requested_update: bool = Field(False, description="Flag: True if user explicitly requested to update/redo a completed task.")

    # 5. Error/Debugging Information
    error_message: Optional[str] = Field(None, description="Stores any error messages encountered during processing.")
    debug_info: Dict[str, Any] = Field(default_factory=dict, description="Dictionary for storing various debug-related information.")